/* eslint-disable @typescript-eslint/unbound-method */
/* eslint-disable @typescript-eslint/class-literal-property-style */
/* eslint-disable @typescript-eslint/no-unsafe-argument */
/* eslint-disable @typescript-eslint/no-explicit-any */
import { Hookable } from 'hookable';
import {
  applyPatches,
  enablePatches,
  freeze,
  Objectish,
  Patch,
  produce,
} from 'immer';
import { difference, get, merge, set } from 'lodash-es';
import { exec, execSync } from 'node:child_process';
import { existsSync, readFileSync } from 'node:fs';
import { mkdir, readFile, unlink, writeFile } from 'node:fs/promises';
import { dirname, join, relative, resolve } from 'node:path';
import { promisify } from 'node:util';
import normalizePackageData from 'normalize-package-data';
import tree, { TreeNode } from 'tree-console';
import {
  Jsonifiable,
  PackageJson as PackageJsonType,
  TsConfigJson,
} from 'type-fest';
import Vinyl from 'vinyl';
import { parse as parseYaml, stringify as stringifyYaml } from 'yaml';

enablePatches();

const gitignoreDefault = `
### Node ###
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*

### Node Patch ###
# Serverless Webpack directories
.webpack/

# Optional stylelint cache

# SvelteKit build / generate output
.svelte-kit
`.split('\n');

const pexec = promisify(exec);
type NodeType = 'component' | 'project' | 'file' | 'node';

const relativeToCwd = (path: string, cwd: string = process.cwd()) => {
  return './' + relative(cwd, path);
};

interface Scope {
  parent?: Scope;
  get component(): Component | undefined;
  get root(): Scope;
  get project(): Project<ProjectOptions>;
  get tags(): Set<string>;
  get nodeType(): NodeType;
  children: Node[];
  addChild(node: Node): void;
  hasAllTags(...tag: string[]): boolean;
  hasAnyTag(...tag: string[]): boolean;
}

export type Type<T> = new (...args: any[]) => T;

interface SynthOptions {
  removeDeletedFiles?: boolean;
}
export abstract class Node extends Hookable implements Scope {
  nodeName: string;
  parent?: Scope;
  tags = new Set<string>();
  children: Node[] = [];
  // eslint-disable-next-line @typescript-eslint/class-literal-property-style
  get nodeType(): NodeType {
    return 'node';
  }
  constructor(parent?: Scope, nodeName?: string) {
    super();
    this.nodeName = nodeName
      ? this.constructor.name + '(' + nodeName + ')'
      : this.constructor.name;
    this.parent = parent;
    if (this instanceof Project) {
      parent?.project?.addSubproject(this);
    } else if (this instanceof Component) {
      parent?.project?.addComponent(this);
    } else if (this instanceof File) {
      parent?.project?.addFile(this);
    }
    parent?.addChild(this);

    // this.beforeEach(event => {
    //  console.log('before', event, this.nodeName);
    // });
    // this.afterEach(event => {
    //  console.log('after', event, this.nodeName);
    // });
    this.debug('Created');
  }

  get root(): Scope {
    if (!this.parent) return this;
    return this.parent.root;
  }

  get project(): Project<ProjectOptions> {
    if (this instanceof Project) return this;
    return assertRequired(this.parent?.project, 'A parent project is required');
  }

  get component(): Component | undefined {
    if (this instanceof Component) return this;
    return this.parent?.component;
  }

  addChild(node: Node) {
    this.children.push(node);
    this.debug('Adding', node.nodeType, node.nodeName);
  }

  log(...message: any[]) {
    console.log('INFO', this.nodeName, ...message);
  }

  warn(...message: any[]) {
    console.warn('WARN', this.nodeName, ...message);
  }

  debug(...message: any[]) {
    console.debug('DEBUG', this.nodeName, ...message);
  }

  findComponent<T extends Node>(
    predicate: (node: Node) => T | undefined,
  ): T | undefined {
    const component = this.children.find(predicate);
    if (component) return component as T;
    for (const node of this.children) {
      const childComponent = node.findComponent(predicate);
      if (childComponent) return childComponent;
    }
    return undefined;
  }

  requiredComponent<T extends Node>(predicate: (node: Node) => T): T {
    return assertRequired(this.findComponent(predicate));
  }

  findFileOf<X extends File<any, any>>(
    path: string,
    instanceType: Type<X>,
  ): X | undefined {
    return this.project.findComponent(node =>
      node instanceof instanceType ? File.of(node, path) : undefined,
    ) as X | undefined;
  }

  findFile<T, O extends FileOptions>(path: string): File<T, O> | undefined {
    return this.project.findComponent(node =>
      node instanceof File ? File.of(node, path) : undefined,
    );
  }

  hasAllTags(...tags: string[]) {
    for (const tag of tags) {
      if (!this.tags.has(tag)) {
        return false;
      }
    }
    return true;
  }

  hasAnyTag(...tags: string[]) {
    for (const tag of tags) {
      if (this.tags.has(tag)) {
        return true;
      }
    }
    return false;
  }

  protected async preSynthetize(options: SynthOptions) {
    await this.callHook('synth:before', options);
    for (const child of this.children) {
      await child.preSynthetize(options);
    }
  }

  protected async postSynthetize(options: SynthOptions) {
    for (const child of this.children) {
      await child.postSynthetize(options);
    }
    await this.callHook('synth:after', options);
  }

  protected async synthetize(options: SynthOptions) {
    for (const child of this.children) {
      await child.synthetize(options);
    }
    await this.callHook('synth', options);
  }

  async synth(options: SynthOptions = {}) {
    await this.preSynthetize(options);
    await this.synthetize(options);
    await this.postSynthetize(options);
  }

  protected async exec(cmd: string, opts: { cwd?: string } = {}) {
    await this.callHook('exec:before', cmd, opts);
    try {
      const cwd = opts.cwd ?? this.project.options.path;
      this.debug('Executing [' + cmd + '] on [' + relativeToCwd(cwd) + ']');
      const result = await pexec(cmd, { cwd });
      this.debug('Result:', result);
      return result;
    } finally {
      await this.callHook('exec:after', cmd, opts);
    }
  }

  execSync(cmd: string, opts: { cwd?: string } = {}): string {
    return this.useSyncHook(
      'execSync',
      [cmd, opts],
      (cmd: string, opts: { cwd?: string } = {}): string => {
        return execSync(cmd, {
          cwd: opts.cwd ?? this.project.options.path,
        })
          .toString()
          .trim();
      },
    );
  }

  async useHook<NameT extends string, FN extends (...args: any) => R, R>(
    name: NameT,
    arguments_: Parameters<FN>,
    fn: FN,
  ): Promise<R> {
    let result = null;
    try {
      await this.callHook(`${name}:before`, arguments_);
      result = await Promise.resolve(
        fn(...Array.prototype.slice.call(arguments_)),
      );
      return result;
    } finally {
      await this.callHook(`${name}:after`, arguments_, result);
    }
  }

  useSyncHook<NameT extends string, FN extends (...args: any) => R, R>(
    name: NameT,
    arguments_: Parameters<FN>,
    fn: FN,
  ): R {
    let result = null;
    const args = Array.prototype.slice.call(arguments_);
    try {
      // this.callHook(`${name}:before`, ...args);
      result = fn(...args);
      return result;
    } finally {
      // this.callHook(`${name}:after`, ...args, result);
    }
  }

  toTreeNode(): TreeNode {
    return {
      name: this.nodeName,
      children: this.children.map(it => it.toTreeNode()),
    };
  }
}

export abstract class ScopedNode extends Node implements Scope {}

export const ProjectDefaults = {
  gitignore: gitignoreDefault,
  buildDir: 'dist',
  sourceSets: {
    main: {
      pattern: ['src/**/*.ts'],
    },
    tests: {
      pattern: ['test/**/*.ts'],
    },
  } satisfies ProjectOptions['sourceSets'],
};

export interface ProjectOptions {
  name: string;
  outdir: string;
  cwd: string;
  path: string;
  version?: string;
  description?: string;
  gitignore?: boolean | string[];
  sourceSets?: SourceSets;
  buildDir: string;
}

type SourceSetType = 'main' | 'tests' | 'assets' | AnyString;

type SourceSets = {
  [name in SourceSetType]?: SourceSet;
};
interface SourceSet {
  pattern: string[];
}

export type ProjectInitialOptions = Pick<
  ProjectOptions,
  'name' | 'version' | 'description'
> &
  Partial<ProjectOptions>;

export interface ProjectMetadata {
  project: string;
  files: string[];
  custom: Record<string, Jsonifiable>;
}

export abstract class Project<
  T extends ProjectOptions = ProjectOptions,
> extends ScopedNode {
  subprojects: Project[] = [];
  components: Component[] = [];
  files: File<any, FileOptions>[] = [];
  options: T;
  customMetadata: Record<string, Jsonifiable> = {};
  private metadataFile: JsonFile<ProjectMetadata>;
  get nodeType(): NodeType {
    return 'project';
  }

  static defaults(
    options: ProjectInitialOptions,
    scope?: Scope,
  ): ProjectOptions {
    const cwd = options?.cwd ?? scope?.project?.options?.path ?? process.cwd();
    const outdir = options.outdir ?? '.';
    const path = join(cwd, outdir);
    return {
      cwd,
      outdir,
      path,
      sourceSets: options.sourceSets ?? ProjectDefaults.sourceSets,
      buildDir: options.buildDir ?? ProjectDefaults.buildDir,
      ...options,
    };
  }
  constructor(scope: Scope | undefined | null = undefined, options: T) {
    super(scope ?? undefined, options.name);
    this.options = options;
    const gitignore = this.options.gitignore ?? true;
    if (gitignore) {
      new Gitignore(this, {
        pattern: gitignore ? ProjectDefaults.gitignore : gitignore,
      });
    }
    this.metadataFile = new JsonFile<ProjectMetadata>(
      this,
      { base: '.qdk/meta.json', writeOnSynth: false },
      {
        project: this.options.name,
        custom: this.customMetadata,
        files: this.files
          .filter(file => !file.options.sample)
          .map(it => it.relativePath)
          .sort(),
      },
    );
    this.hook('synth:after', async (options: SynthOptions) => {
      await new TextFile(
        this,
        { base: '.qdk/tree.txt' },
        tree.getStringTree([this.toTreeNode()]),
      ).write();
      const previousFiles = (this.metadataFile.loadedData?.files ?? []).sort();
      const managedFiles = this.files
        .filter(file => !file.options.sample)
        .map(it => it.relativePath)
        .sort();
      const removedFiles = difference(previousFiles, managedFiles);
      this.debug('Previously managed files:', previousFiles);
      this.debug('Files to delete:', removedFiles);
      this.debug('New managed files:', managedFiles);

      this.metadataFile.update(() => ({
        project: this.options.name,
        custom: this.customMetadata,
        files: managedFiles,
      }));
      if (options.removeDeletedFiles ?? true) {
        await Promise.all(
          removedFiles.map(async file => {
            this.debug('Deleting file', file);
            await unlink(this.resolvePath(file));
          }),
        );
      }
      await this.metadataFile.write();
    });
  }

  resolvePath(path: string) {
    return resolve(this.project.options.path, path);
  }

  addSubproject(project: Project) {
    this.debug('Tracking subproject', project.nodeName);
    this.subprojects.push(project);
  }

  addComponent(component: Component) {
    this.debug('Tracking component', component.nodeName);
    this.components.push(component);
  }

  addFile(file: File<any, FileOptions>) {
    this.debug('Tracking file', file.nodeName);
    this.files.push(file);
  }

  get sourceSets(): SourceSets {
    return this.options.sourceSets ?? {};
  }

  get buildDir(): string {
    return this.options.buildDir;
  }
}

export type SimpleProjectOptions = ProjectOptions & {};

export type SimpleProjectInitialOptions = Pick<SimpleProjectOptions, 'name'> &
  ProjectInitialOptions;

export class SimpleProject<T extends SimpleProjectOptions> extends Project<T> {
  static defaults<T extends SimpleProjectOptions>(
    options: SimpleProjectInitialOptions,
    scope?: Scope,
  ): T {
    const opts = Project.defaults(options, scope);
    return {
      ...opts,
    } as T;
  }
  constructor(
    scope: Scope | undefined | null,
    options: SimpleProjectInitialOptions,
  ) {
    super(scope, SimpleProject.defaults(options, scope ?? undefined));
  }
}

export abstract class Component<T = unknown> extends ScopedNode {
  options: T;
  get nodeType(): NodeType {
    return 'component';
  }
  constructor(scope: Scope, options: T, nodeName?: string) {
    super(scope, nodeName);
    this.options = options;
    if (this.options) {
      this.debug('Options', this.options);
    }
  }
}

export class ManagedFile {
  scope: Scope;
  constructor(scope: Scope) {
    this.scope = scope;
  }
}

export interface PackageJsonOptions {
  name: string;
  version: string;
  description: string;
}

export type PackageJsonInitialOptions = Partial<PackageJsonOptions>;
export const PackageJsonDefaults = {
  version: '0.0.1',
  description: '',
};
export class PackageJson extends Component<PackageJsonOptions> {
  static defaults(
    options: PackageJsonInitialOptions,
    scope: Project,
  ): PackageJsonOptions {
    return {
      name: scope.options.name,
      version: scope.options.version ?? PackageJsonDefaults.version,
      description: scope.options.description ?? PackageJsonDefaults.description,
      ...options,
    };
  }
  static of(node: Node): PackageJson | undefined {
    return node instanceof PackageJson ? node : undefined;
  }
  static for(scope: Scope): PackageJson | undefined {
    return scope.project.findComponent(PackageJson.of);
  }
  static required(scope: Scope): PackageJson {
    return assertRequired(
      this.for(scope),
      'PackageJson not found in the scope ' + scope.nodeType,
    );
  }
  private file: JsonFile<PackageJsonType>;
  constructor(scope: Project, options: PackageJsonInitialOptions = {}) {
    super(scope, PackageJson.defaults(options, scope));
    this.file = new JsonFile<PackageJsonType>(
      this,
      { base: 'package.json', readOnInit: true },
      {
        name: this.options.name,
        version: this.options.version,
        description: this.options.description,
      },
    );
    this.hook('synth:before', () => {
      this.file.update(normalizePackageData);
    });
    this.hook('synth:after', async () => {
      // if (this.file.changed) {
      await PackageManager.required(this).install();
      // }
    });
  }
  private buildDepsObject(
    defaults: Partial<Record<string, string>> | undefined,
    ...dependencies: string[]
  ) {
    return dependencies.reduce(
      (deps, dependency) => {
        const { name, version } = parseDependency(dependency);
        deps[name] =
          version ??
          defaults?.[name] ??
          PackageManager.required(this).latestVersion(name);
        return deps;
      },
      {} as Record<string, string>,
    );
  }
  addDeps(...dependencies: string[]): this {
    const deps =
      get(this.file.loadedData, 'dependencies') ??
      ({} as Partial<Record<string, string>>);
    this.file.mergeField(
      'dependencies',
      this.buildDepsObject(deps, ...dependencies),
    );
    return this;
  }
  addDevDeps(...dependencies: string[]): this {
    const devDeps = get(this.file.loadedData, 'devDependencies');
    this.file.mergeField(
      'devDependencies',
      this.buildDepsObject(devDeps, ...dependencies),
    );
    return this;
  }
  addPeerDeps(...dependencies: string[]): this {
    const peerDeps = get(this.file.loadedData, 'peerDependencies');
    this.file.mergeField(
      'peerDependencies',
      this.buildDepsObject(peerDeps, ...dependencies),
    );
    return this;
  }
  setEngine(name: string, version: string): this {
    this.file.mergeField('engine', { [name]: version });
    return this;
  }
  setScript(name: string, script: string): this {
    this.file.mergeField('scripts', { [name]: script });
    return this;
  }
  update(mutate: (data: PackageJsonType) => PackageJsonType | void) {
    this.file.update(mutate);
  }
}

export interface FileOptions {
  cwd: string;
  base: string;
  readOnInit?: boolean;
  sample?: boolean;
  writeOnSynth?: boolean;
}
export type FileInitialOptions = Partial<FileOptions> &
  Pick<FileOptions, 'base'>;

export interface FileCodec<T = any> {
  serializer: (data: T) => Buffer;
  deserializer: (buffer: Buffer) => T;
}
export class File<T, O extends FileOptions = FileOptions> extends Node {
  protected file: Vinyl;
  protected codec: FileCodec<T>;
  private data: T;
  private patches: Patch[][] = [];
  private revertPatches: Patch[][] = [];
  loadedData?: T;
  protected raw?: Buffer;
  options: O;
  changed?: boolean;
  get nodeType(): NodeType {
    return 'file';
  }

  get relativePath(): string {
    return relativeToCwd(this.file.path, this.project.options.path);
  }

  static of<T, O extends FileOptions = FileOptions>(
    node: Node,
    base?: string,
  ): File<T, O> | undefined {
    if (!(node instanceof File)) return;
    if (base && (node as File<any, FileOptions>).options.base !== base) return;
    return node;
  }
  static defaults(options: FileInitialOptions, scope: Scope): FileOptions {
    return {
      cwd: join(scope.project.options.cwd, scope.project.options.outdir),
      ...options,
    };
  }
  constructor(
    scope: Scope,
    options: FileInitialOptions,
    codec: FileCodec<T>,
    initialData: T,
  ) {
    const opts = File.defaults(options, scope);
    super(scope, opts.base);
    this.options = opts as O;
    this.codec = codec;
    this.data = freeze(initialData, true);
    this.file = new Vinyl({
      cwd: opts.cwd,
      base: opts.base,
      path: join(opts.cwd, opts.base),
    });
    if (this.options.readOnInit ?? true) {
      this.readSync({
        silentWhenMissing: true,
        updateData: this.options.sample ?? false,
      });
    }
    if (this.options.writeOnSynth ?? true) {
      this.addHooks({
        synth: async () => {
          await this.write();
        },
      });
    }
  }

  async read(opts: { updateData?: boolean } = { updateData: false }) {
    return this.useHook(
      'read',
      [opts],
      async (opts: { updateData?: boolean } = { updateData: false }) => {
        this.debug('Reading file', this.relativePath);
        this.raw = await readFile(this.file.path);
        this.loadedData = this.codec.deserializer(this.raw);
        if (opts.updateData) {
          this.debug('Using loaded data');
          this.data = this.loadedData;
        }
      },
    );
  }

  readSync(
    opts: { updateData?: boolean; silentWhenMissing?: boolean } = {
      silentWhenMissing: false,
      updateData: false,
    },
  ) {
    if (opts.silentWhenMissing && !existsSync(this.file.path)) {
      this.debug('File', this.relativePath, 'do not exist');
      return;
    }
    this.debug('Reading (sync) file', this.relativePath);
    this.raw = readFileSync(this.file.path);
    this.loadedData = this.codec.deserializer(this.raw);
    if (opts.updateData) {
      this.debug('Using loaded data');
      this.data = this.loadedData;
    }
  }

  async write() {
    const buffer = this.codec.serializer(this.data);
    this.changed = !this.raw || !buffer.equals(this.raw);
    if (this.changed) {
      await this.useHook(
        'write',
        [this.file, this.data, buffer],
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        async (_file, _data, _buffer) => {
          this.raw = buffer;
          if (!this.loadedData) {
            const fileDirname = dirname(this.file.path);
            this.debug(
              'Create directory if needed',
              relativeToCwd(fileDirname),
            );
            await mkdir(fileDirname, { recursive: true });
          }
          this.debug('Writing file', this.relativePath);
          await writeFile(this.file.path, this.raw);
        },
      );
    } else {
      // console.log('didnt change', this);
      this.debug('Nothing changed');
    }
  }

  update(mutate: (data: T) => T | void, record = true) {
    this.data = produce(this.data, mutate, (patches, revertPatches) => {
      this.debug('Apply patches:', patches);
      if (record) {
        this.patches.push(patches);
        this.revertPatches.push(revertPatches);
        // this.debug('Revert patches', revertPatches);
      }
    });
  }

  undo(): boolean {
    const patches = this.revertPatches.pop();
    if (patches) {
      this.debug('Undo patches', patches);
      this.update(data => {
        return applyPatches(data as Objectish, patches) as T;
      }, false);
      return true;
    }
    this.debug('Nothing to undo');
    return false;
  }
}

export type JsonFileOptions = FileOptions & {};
export type JsonFileInitialOptions = FileInitialOptions & {};

const createJsonCodec = <T = Jsonifiable>(): FileCodec<T> => ({
  serializer: (data: T) => Buffer.from(JSON.stringify(data, null, 2)),
  deserializer: buffer => JSON.parse(buffer.toString('utf8')) as T,
});

export class JsonFile<T = Jsonifiable> extends File<T, JsonFileOptions> {
  static ofJson(node: Node, path: string): JsonFile | undefined {
    return node instanceof JsonFile
      ? (File.of(node, path) as JsonFile | undefined)
      : undefined;
  }
  static ofPath(path: string) {
    return (node: Node): JsonFile | undefined => {
      return JsonFile.ofJson(node, path);
    };
  }
  static forPath(scope: Scope, path: string): JsonFile | undefined {
    return scope.project.findComponent(JsonFile.ofPath(path));
  }
  constructor(scope: Scope, options: JsonFileInitialOptions, initialData: T) {
    super(scope, options, createJsonCodec(), initialData);
  }

  mergeField(property: string, newValue: T, defaultValue: any = {}) {
    this.update(data => {
      const currentValue: unknown = get(data, property);
      this.useSyncHook(
        'mergeField',
        [property, newValue, currentValue],
        (property, newValue, currentValue) => {
          set(
            data as object,
            property,
            merge(defaultValue, currentValue, newValue),
          );
          this.debug(`merge field[${property}] with`, newValue);
        },
      );
    });
  }

  merge(newValue: T) {
    this.update(data => {
      this.useSyncHook('merge', [newValue, data], (newValue, data) => {
        merge(data, newValue);
        this.debug(`merge with`, newValue);
      });
    });
  }
}

const createTextCodec = (): FileCodec<string> => ({
  serializer: (data: string) => Buffer.from(data),
  deserializer: buffer => buffer.toString('utf8'),
});

export type TextFileOptions = FileOptions & {};
export type TextFileInitialOptions = FileInitialOptions & {};

export class TextFile extends File<string, TextFileOptions> {
  static ofText(node: Node, path: string): TextFile | undefined {
    return node instanceof TextFile
      ? (File.of(node, path) as TextFile | undefined)
      : undefined;
  }
  static ofPath(path: string) {
    return (node: Node): TextFile | undefined => {
      return TextFile.ofText(node, path);
    };
  }
  static forPath(scope: Scope, path: string): TextFile | undefined {
    return scope.project.findComponent(TextFile.ofPath(path));
  }
  constructor(
    scope: Scope,
    options: TextFileInitialOptions,
    initialData: string,
  ) {
    super(scope, options, createTextCodec(), initialData);
  }

  change(newValue: string) {
    this.update(() => {
      return this.useSyncHook('set', [newValue], newValue => {
        try {
          return newValue as string;
        } finally {
          this.debug(`set`, newValue);
        }
      });
    });
  }
}

export abstract class PackageManager<T = unknown> extends Component<T> {
  abstract run(cmd: string): ReturnType<typeof this.exec>;
  abstract install(opts?: { frozen?: boolean }): ReturnType<typeof this.exec>;
  static of(node: Node): PackageManager | undefined {
    return node instanceof PackageManager ? node : undefined;
  }
  static for(scope: Scope): PackageManager | undefined {
    return scope.project.findComponent(PackageManager.of);
  }
  static required(scope: Scope): PackageManager {
    return assertRequired(scope.project.findComponent(PackageManager.of));
  }
  latestVersion(dependencyName: string) {
    this.debug('Resolving npm latest version for', dependencyName);
    return this.execSync(`npm view ${dependencyName} version`, {
      cwd: process.cwd(),
    });
  }
}

export const NpmPackagerManagerDefaults = {};
interface NpmPackageManagerOptions {
  workspace?: boolean;
}
type NpmPackageManagerInitialOptions = Partial<NpmPackageManagerOptions>;

export class NpmPackageManager extends PackageManager<NpmPackageManagerOptions> {
  static defaults(
    options: NpmPackageManagerInitialOptions,
  ): NpmPackageManagerOptions {
    return {
      ...options,
    };
  }
  constructor(scope: Project, options: NpmPackageManagerInitialOptions = {}) {
    const opts = NpmPackageManager.defaults(options);
    super(scope, opts);
    if (this.options.workspace) {
      this.hook('synth:before', () => {
        PackageJson.required(this).update(data => {
          data.workspaces = this.project.subprojects.map(project =>
            relative(this.project.options.path, project.options.path),
          );
        });
      });
    }
  }
  async run(cmd: string) {
    return await this.exec(`npm ${cmd}`);
  }
  async install(opts: { frozen?: boolean } = {}) {
    this.debug('Install dependencies. Options =', opts);
    return await this.run(opts.frozen ? 'ci' : 'install');
  }
}

const PnpmPackagerManagerDefaults = {
  version: '^9.11.0',
};
interface PnpmPackageManagerOptions {
  workspace?: boolean;
  version: string;
}
type PnpmPackageManagerInitialOptions = Partial<PnpmPackageManagerOptions>;

export class PnpmPackageManager extends PackageManager<PnpmPackageManagerOptions> {
  static defaults(
    options: PnpmPackageManagerInitialOptions,
  ): PnpmPackageManagerOptions {
    return {
      version: options.version ?? PnpmPackagerManagerDefaults.version,
      ...options,
    };
  }
  constructor(scope: Project, options: PnpmPackageManagerInitialOptions = {}) {
    const opts = PnpmPackageManager.defaults(options);
    super(scope, opts, opts.version);
    if (this.options.workspace) {
      new PnpmWorkspace(this);
    }
    this.hook('synth:before', () => {
      PackageJson.required(this).setEngine('pnpm', this.options.version);
    });
  }
  async run(cmd: string) {
    return await this.exec(`npx pnpm@${this.options.version} ${cmd}`);
  }
  async install(opts: { frozen?: boolean } = {}) {
    this.debug('Install dependencies. Options =', opts);
    return this.run(`install${opts.frozen ? ' --frozen-lockfile' : ''}`);
  }
}

export type YamlFileOptions = FileOptions & {};
export type YamlFileInitialOptions = FileInitialOptions & {};
type Yamlifiable = Jsonifiable;

const createYamlCodec = <T = Yamlifiable>(): FileCodec<T> => ({
  serializer: (data: T) => Buffer.from(stringifyYaml(data, null, 2)),
  deserializer: buffer => parseYaml(buffer.toString('utf8')) as T,
});

export class YamlFile<T extends Yamlifiable = Yamlifiable> extends File<
  T,
  YamlFileOptions
> {
  constructor(scope: Scope, options: YamlFileInitialOptions, initialData: T) {
    super(scope, options, createYamlCodec(), initialData);
  }

  mergeField(property: string, newValue: T, defaultValue: any = {}) {
    this.update(data => {
      const currentValue: unknown = get(data, property);
      this.useSyncHook(
        'mergeField',
        [property, newValue, currentValue],
        (property, newValue, currentValue) => {
          set(
            data as object,
            property,
            merge(defaultValue, currentValue, newValue),
          );
          this.debug(`merge field[${property}] with`, newValue);
        },
      );
    });
  }

  merge(newValue: T) {
    this.update(data => {
      this.useSyncHook('merge', [newValue, data], (newValue, data) => {
        try {
          return merge(data, newValue) as T;
        } finally {
          this.debug('merge with', newValue);
        }
      });
    });
  }
}

export class PnpmWorkspace extends Component {
  yaml: YamlFile;
  constructor(scope: Component) {
    super(scope, undefined);
    this.yaml = new YamlFile<Yamlifiable>(
      this,
      { base: 'pnpm-workspace.yaml' },
      {
        packages: [],
      },
    );
    this.hook('synth:before', () => {
      this.yaml.merge({
        packages: scope.project.subprojects.map(project =>
          relative(scope.project.options.path, project.options.path),
        ),
      });
    });
  }
}

export const TypescriptDefaults = {
  version: '^5.6.2',
};
export interface TypescriptOptions {
  version: string;
  tsconfig?: TsConfigInitialOptions;
}
export type TypescriptInitialOptions = Partial<TypescriptOptions>;

export class Typescript extends Component {
  tsconfig: TsConfig;
  static defaults(
    options: TypescriptInitialOptions,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    scope: Project,
  ): TypescriptOptions {
    return {
      version: options.version ?? TypescriptDefaults.version,
      ...options,
    };
  }
  constructor(scope: Project, options: TypescriptInitialOptions = {}) {
    const opts = Typescript.defaults(options, scope);
    super(scope, opts, opts.version);
    this.tsconfig = new TsConfig(this, opts.tsconfig);
    PackageJson.required(this).addDevDeps(`typescript@${opts.version}`);
  }
}

export const TsConfigBases = {
  Recommended: '@tsconfig/recommended',
  Bun: '@tsconfig/bun',
  CreateReactApp: '@tsconfig/create-react-app',
  Cypress: '@tsconfig/cypress',
  Deno: '@tsconfig/deno',
  Docusaurusv2: '@tsconfig/docusaurus',
  Ember: '@tsconfig/ember',
  Nextjs: '@tsconfig/next',
  NodeLTS: '@tsconfig/node-lts',
  Node10: '@tsconfig/node10',
  Node12: '@tsconfig/node12',
  Node14: '@tsconfig/node14',
  Node16: '@tsconfig/node16',
  Node17: '@tsconfig/node17',
  Node18: '@tsconfig/node18',
  Node19: '@tsconfig/node19',
  Node20: '@tsconfig/node20',
  Node21: '@tsconfig/node21',
  Node22: '@tsconfig/node22',
  Nuxt: '@tsconfig/nuxt',
  ReactNative: '@tsconfig/react-native',
  Remix: '@tsconfig/remix',
  Strictest: '@tsconfig/strictest',
  Svelte: '@tsconfig/svelte',
  Taro: '@tsconfig/taro',
  ViteReact: '@tsconfig/vite-react',
};
export const TsConfigDefaults = {
  extends: [TsConfigBases.Node20],
};
type TsConfigBase = (typeof TsConfigBases)[keyof typeof TsConfigBases];
type AnyString = string & Record<never, never>;

export interface TsConfigOptions {
  extends?: (TsConfigBase | AnyString)[];
  config: TsConfigJson;
  devDependencies: string[];
}
export type TsConfigInitialOptions = Omit<
  Partial<TsConfigOptions>,
  'devDependencies'
>;

export class TsConfig extends Component<TsConfigOptions> {
  json: JsonFile<TsConfigJson>;
  static defaults(
    options: TsConfigInitialOptions,
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    scope: Scope,
  ): TsConfigOptions {
    const config: TsConfigJson = options.config ?? {};

    const configExtends =
      typeof config.extends === 'string'
        ? [config.extends]
        : (config.extends ?? []);
    const optionsExtends = options.extends ?? [];

    // add options.extends to the config.extends
    config.extends = [...new Set([...configExtends, ...optionsExtends])];

    // set default config extends if no extends or no config provided
    if (!config.extends?.length && !options.config) {
      config.extends = TsConfigDefaults.extends;
    }

    // parse extends dependencies
    const devDependenciesMap: Record<string, string | undefined> = {};
    if (config.extends?.length) {
      config.extends = config.extends?.map(dependency => {
        const { name, version } = parseDependency(dependency);
        devDependenciesMap[name] = version ?? undefined;
        return name;
      });
    }
    const devDependencies = Object.entries(devDependenciesMap).map(
      ([name, version]) => (version ? `${name}@${version}` : name),
    );

    return {
      ...options,
      devDependencies,
      config,
    };
  }
  constructor(scope: Scope, options: TsConfigInitialOptions = {}) {
    const opts = TsConfig.defaults(options, scope);
    super(scope, opts);
    this.json = new JsonFile<TsConfigJson>(
      this,
      { base: 'tsconfig.json' },
      opts.config,
    );
    if (this.options.extends?.length && this.options.config?.extends?.length) {
      this.warn(
        "Merged [...options.extends, ...config.extends]. Check if it's the desired behavior",
      );
    }

    // add dependencies to the package json
    if (opts.devDependencies.length) {
      const packageJson = PackageJson.required(this);
      packageJson.addDevDeps(...opts.devDependencies);
    }
  }
}

export interface PrettierOptions {
  scripts?: {
    format?: string;
  };
}
export class Prettier extends Component {
  constructor(scope: Scope, options: PrettierOptions = {}) {
    super(scope, options);
    PackageJson.required(this)
      .addDevDeps('prettier')
      .setScript('format', options.scripts?.format ?? 'prettier . --write');
    new JsonFile(
      this,
      { base: '.prettierrc' },
      {
        arrowParens: 'avoid',
        singleQuote: true,
        plugins: [],
        overrides: [],
      },
    );
  }
}

export interface GitignoreOptions {
  pattern?: string[];
}
export class Gitignore extends Component<GitignoreOptions> {
  private ignored: string[] = [];
  constructor(scope: Scope, options: GitignoreOptions) {
    super(scope, options);
    const file = new TextFile(this, { base: '.gitignore' }, '');
    if (this.options.pattern?.length) this.add(...this.options.pattern);
    this.hook('synth:before', () => {
      file.update(() => this.ignored.join('\n'));
    });
  }
  add(...pattern: string[]): this {
    this.ignored.push(...pattern);
    return this;
  }
}

export const ESLintDefaults = {
  version: '^9.0.0',
  prettier: 'auto' as const,
};
interface ESLintOptions {
  version: string;
  prettier?: PrettierOptions | 'manual' | 'auto' | 'disabled';
}
type ESLintInitialOptions = Partial<ESLintOptions>;
export class ESLint extends Component<ESLintInitialOptions> {
  static defaults(options: ESLintInitialOptions): ESLintOptions {
    return {
      version: options.version ?? ESLintDefaults.version,
      prettier: ESLintDefaults.prettier,
      ...options,
    };
  }
  constructor(scope: Project, options: ESLintInitialOptions = {}) {
    super(scope, ESLint.defaults(options));
    PackageJson.required(this)
      .addDevDeps(
        'eslint@' + ESLintDefaults.version,
        'typescript-eslint',
        '@eslint/js',
        'globals',
      )
      .setScript('eslint', 'eslint')
      .setScript('eslint:fix', 'eslint --fix');

    this.hook('synth:after', async () => {
      await PackageManager.for(this)?.run('run eslint:fix');
    });
    const { prettier } = this.options;
    const enablePrettier = prettier && prettier !== 'disabled';
    if (enablePrettier) {
      PackageJson.required(this).addDevDeps(
        'eslint-plugin-prettier',
        'eslint-config-prettier',
      );
      if (typeof prettier === 'object') {
        new Prettier(this, prettier);
      } else if (prettier === 'auto') {
        new Prettier(this);
      }
    }
    const eslintConfigFilename = 'eslint.config.mjs';
    const sources = [
      eslintConfigFilename,
      ...(this.project.sourceSets?.main?.pattern ?? []),
      ...(this.project.sourceSets?.tests?.pattern ?? []),
    ];
    const ignores = [this.project.buildDir + '/**/*'];
    new TextFile(
      this,
      { base: eslintConfigFilename },
      `
import globals from "globals";
import eslint from "@eslint/js";
import tseslint from "typescript-eslint";
${enablePrettier ? `import eslintPluginPrettierRecommended from "eslint-plugin-prettier/recommended";` : ''}

export default tseslint.config(
  eslint.configs.recommended,
  ...tseslint.configs.recommendedTypeChecked,
  ...tseslint.configs.stylisticTypeChecked,
  ${enablePrettier ? `eslintPluginPrettierRecommended,` : ''}
  {files: ${JSON.stringify(sources)}},
  {ignores: ${JSON.stringify(ignores)}},
  {languageOptions: { globals: globals.nodeBuiltin }},
   {
    languageOptions: {
      parserOptions: {
        projectService: {
          allowDefaultProject: [${JSON.stringify(eslintConfigFilename)}, "*.ts", "*.js"]
        },
        tsconfigRootDir: import.meta.dirname,
      },
    },
  },
);`,
    );
  }
}

function parseDependency(spec: string) {
  const scope = spec.startsWith('@');
  if (scope) {
    spec = spec.substring(1);
  }
  const [module, ...version] = spec.split('@');
  const name = scope ? `@${module}` : module;
  if (version.length == 0) {
    return { name };
  } else {
    return { name, version: version?.join('@') };
  }
}

function assertRequired<T>(
  instance?: T | null,
  message = 'Instance is required',
): T {
  if (instance === null || typeof instance === 'undefined') {
    throw new Error(message);
  }
  return instance;
}

/*

Consider Immer for json data mutation

Consider https://www.npmjs.com/package/normalize-package-data for normalized package json definition

Consider https://github.com/gulpjs/interpret to load js/ts/tsx files with the proper resolver

Consider https://www.npmjs.com/package/magicast for ts/js file manipulation

Trying to find the right filesystem abtraction:
- https://www.npmjs.com/package/unionfs
- https://github.com/streamich/memfs for tests
- https://www.npmjs.com/package/mem-fs
- https://www.npmjs.com/package/vinyl + vinyl-fs
- https://www.npmjs.com/package/@ui5/fs


interesting tsconfig file loader https://www.npmjs.com/package/get-tsconfig

anymatch -  match a string against a regular expression, glob, string, or function  https://www.npmjs.com/package/anymatch

liftoff - app configuration loader - https://github.com/gulpjs/liftoff

nopt - cmd options - https://www.npmjs.com/package/nopt


*/
